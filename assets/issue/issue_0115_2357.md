# 작품 업로드(데이터 영속화) 기능 분석 보고서

## 1. 현재 구현 방식 (Current Implementation)
현재 iMery 앱은 이미지를 **Base64 문자열**로 변환하여 JSON 페이로드에 포함시킨 후, 백엔드 API로 전송하는 방식을 사용하고 있습니다.

### 데이터 흐름 (Data Flow)
1.  **이미지 선택 (`UploadModal.jsx`)**:
    -   `FileReader`를 사용하여 사용자가 선택한 파일을 `readAsDataURL`로 읽어들임.
    -   결과값(Base64 String)을 `previewImage` 및 상위 컴포넌트로 전달.
2.  **데이터 구성 (`ReviewForm.jsx`)**:
    -   `onSave` 호출 시 `image_url` 필드에 Base64 문자열을 그대로 할당.
3.  **API 요청 (`App.jsx` -> `api/client.js`)**:
    -   `POST /posts/` 엔드포인트로 JSON 데이터 전송.
    -   Payload: `{ ..., "image_url": "data:image/jpeg;base64,/9j/4AAQSw...", ... }`

## 2. 식별된 문제점 (Identified Issues)

### 2.1 대용량 페이로드 문제 (Payload Size Limit)
-   **현상**: 고화질 이미지를 Base64로 인코딩하면 원본 크기 대비 약 **33% 용량이 증가**합니다.
-   **위험**: 일반적인 웹 서버(Nginx, Apache 등)나 클라우드 서비스(Render, AWS API Gateway)는 기본 요청 본문 크기 제한(Client Body Size Limit)이 있습니다 (보통 1MB ~ 10MB).
-   **결과**: 스마트폰으로 촬영한 사진(수 MB)을 업로드할 경우 `413 Payload Too Large` 에러가 발생하여 업로드가 실패할 가능성이 매우 높습니다.

### 2.2 데이터베이스 성능 저하 (Database Performance)
-   만약 백엔드가 이 Base64 문자열을 별도 스토리지(S3 등)가 아닌 DB의 텍스트 컬럼에 직접 저장한다면, DB 스토리지 효율이 급격히 떨어지고 쿼리 성능이 저하됩니다.

### 2.3 네트워크 비효율성
-   JSON 파싱 및 직렬화 과정에서 대규모 문자열 처리는 클라이언트와 서버 양측의 CPU 메모리를 과도하게 소모합니다.

## 3. 해결 방안 (Proposed Solutions)

### [권장] 방안 A: 이미지 업로드 프로세스 분리 (Multipart/Form-Data)
가장 표준적이고 안정적인 해결책입니다.
1.  **API 변경**: 이미지를 처리하는 별도 엔드포인트(`POST /upload`)를 구축하거나, 게시글 생성 API를 `multipart/form-data`를 지원하도록 변경.
2.  **프론트엔드 변경**: `fetch` 요청 시 JSON 대신 `FormData` 객체를 사용하여 파일 바이너리를 직접 전송.

### 방안 B: 프론트엔드 이미지 압축 (Client-side Compression)
백엔드 수정이 어렵거나 임시 조치가 필요한 경우 사용합니다.
1.  `browser-image-compression` 같은 라이브러리를 도입.
2.  업로드 전 이미지를 리사이징(예: 최대 폭 1024px)하고 품질을 낮려(0.7~0.8) 용량을 300KB 미만으로 줄인 후 Base64로 변환하여 전송.

## 4. 결론
현재 "작품 업로드 기능이 제대로 구현되지 않은 듯하다"는 문제는 **이미지 용량 초과로 인한 서버 거부**일 확률이 가장 높습니다.
백엔드 수정이 가능하다면 **방안 A**를, 클라이언트 단에서만 해결해야 한다면 **방안 B**를 적용해야 합니다.
